---
title: "Tools for Data Manipulation"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tools for Data Manipulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

[![Travis-CI Build Status](https://travis-ci.org/wahani/dat.svg?branch=master)](https://travis-ci.org/wahani/dat)
[![codecov.io](https://codecov.io/github/wahani/dat/coverage.svg?branch=master)](https://codecov.io/github/wahani/dat?branch=master)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/dat)](http://cran.r-project.org/package=dat)
[![Downloads](http://cranlogs.r-pkg.org/badges/dat?color=brightgreen)](http://www.r-pkg.org/pkg/dat)

```{r, results='asis', echo=FALSE}
cat(gsub("\\n   ", "", packageDescription("dat", fields = "Description")))
```

## Installation

```{r eval=FALSE}
devtools::install_github("wahani/dat")
```

## Why should you care?

- You probably have to rewrite all your dplyr / data.table code once you put it 
inside a package. I.e. working around non standard evaluation or find another
way to satisfy R CMD check. And you don't like that.
- You like currying as in rlist and purrr.
- You find it annoying that you constantly have to switch between lapply, vapply
and mapply (and other map functions).
- We work together and you have to understand code I wrote.

## map

What we can do with map:

```{r}
library(dat)
map(1:3, ~ .^2) # lapply
map(1:3, numeric(1) : x ~ x^2) # vapply
map(L(1:4, 4:1), integer : f(x, y) ~ rep(x, y)) # mapply + check return type
map(L(1:3, 11:13), c) # zip
map(L(1:3, 11:13), c) %>% 
  { map(do.call(L, .), c) } # unzip
dat <- DataFrame(x = 1, y = "")
map(dat, x ~ x + 1, is.numeric) # only operates on numeric cols
```


## Data Frame

I took the examples from the introductory vignette of dplyr. Things that are not
supported:

- rename
- distinct
- transmute

But you still work with data frames. So you can go back or mix in dplyr features
when you need them.

```{r}
library(nycflights13)
library(dplyr)

dat <- do.call(DataFrame, flights)
str(dat)
```

### Filter rows

```{r results='hide'}
filter(flights, month == 1, day == 1)
dat[~ month == 1 & day == 1]
mutar(dat, ~ month == 1 & day == 1)

slice(flights, 1:10)
dat[~1:10]
dat %>% mutar(~1:10)

# It is truly amazing how many times I tried to subset a data frame with
# dat[1:10] and meant rows. Thats why this is working:
dat[~1:10]
```

```{r}
dat[1:10, ]
```

### Sorting

```{r results='hide'}
arrange(flights, year, month, day)
dat[~order(year, month, day)]
```

```{r}
dat %>% mutar(~order(year, month, day))
```

### Select cols

You can use characters and logicals to select cols of a *DataFrame*. Using
numeric values is not supported; it is error prone and I have spent too many
hours of my life debugging code where I relied on positions in a data frame.

```{r results='hide'}
select(flights, year, month, day)
select(flights, year:day)

# characters are passed into dplyr::select_:
dat %>%
  mutar(c("year", "month", "day")) %>%
  mutar("year:day")

dat[c("year", "month", "day")]["year:day"]
```

You can also pass in a function which checks if you want to select a column, e.g.
select all numeric cols:

```{r}
dat[is.numeric] # or mutar(dat, is.numeric)
```

Or select all cols with missing values in them:

```{r results='hide'}
dat[function(x) any(is.na(x))]
```

### Mutate

```{r results='hide'}
flights %>% 
  mutate(gain = arr_delay - dep_delay,
         speed = distance / air_time * 60)

dat[gain ~ arr_delay - dep_delay,
    speed ~ distance / air_time * 60]
```

```{r}
dat %>%
  mutar(gain ~ arr_delay - dep_delay,
        speed ~ distance / air_time * 60) %>%
  mutar("^gain|speed$") # I assume a regex if the character begin with '^'
```

### Summarise

```{r results='hide'}
group_by(flights, month) %>% 
    summarise(delay = mean(dep_delay, na.rm = TRUE))

dat[delay ~ mean(dep_delay, na.rm = TRUE), 
    by = "month"]
```

```{r}
mutar(dat, 
      delay ~ mean(dep_delay, na.rm = TRUE), 
      by = "month")
```

```{r}
# dplyr:
delay1 <- flights %>%
  group_by(tailnum) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  filter(count > 20, dist < 2000)

# dat #1:
delay2 <- dat[
  count ~ n(),
  dist ~ mean(distance, na.rm = TRUE),
  delay ~ mean(arr_delay, na.rm = TRUE),
  by = "tailnum"
  ] %>%
  .[~count > 20 & dist < 2000]
```

```{r}
# dat #2:
dat %>%
  mutar(count ~ n(),
        dist ~ mean(distance, na.rm = TRUE),
        delay ~ mean(arr_delay, na.rm = TRUE),
        by = "tailnum") %>%
  mutar(~count > 20 & dist < 2000)
```


### Mixing dplyr and mutar

```{r}
dat %>%
  group_by(tailnum) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  mutar(~count > 20 & dist < 2000)
```

