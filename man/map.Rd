% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\docType{methods}
\name{map}
\alias{flatmap}
\alias{flatmap,ANY,function-method}
\alias{map}
\alias{map,ANY,formula-method}
\alias{map,ANY,function-method}
\alias{map,ANY,numericORcharacterORlogical-method}
\alias{map,MList,function-method}
\alias{map,data.frame,function-method}
\title{An implementation of map}
\usage{
map(x, f, ...)

\S4method{map}{ANY,`function`}(x, f, ...)

\S4method{map}{data.frame,`function`}(x, f, p = function(x) TRUE, ...)

\S4method{map}{ANY,formula}(x, f, ...)

\S4method{map}{ANY,numericORcharacterORlogical}(x, f, ...)

\S4method{map}{MList,`function`}(x, f, ..., simplify = FALSE)

flatmap(x, f, ...)

flatmap(x, f, ...)

\S4method{flatmap}{ANY,`function`}(x, f, ..., recursive = FALSE,
  useNames = TRUE)
}
\arguments{
\item{x}{(\link{vector} | \link{data.frame}) if x inherits from data.frame, a
data.frame is returned. Use \link{as.list} if this is not what you want.}

\item{f}{(\link{function} | \link{formula} | character | logical | numeric)
something which can be interpreted as a function. formula objects are
coerced to a function. atomics are used for subsetting in each element of
x. See the examples.}

\item{...}{further arguments passed to \link{lapply} and \link{mapply}}

\item{p}{(function | formula) a predicate function indicating which columns
in a data.frame to use in map. This is a filter for the map operation, the
full data.frame is returned.}

\item{simplify}{see SIMPLIFY in \link{mapply}}

\item{recursive}{see recursive in \link{unlist}}

\item{useNames}{see use.names in \link{unlist}}
}
\description{
An implementation of map.
}
\examples{
map(data.frame(y = 1:10, z = 2), x ~ x + 1)
map(data.frame(y = 1:10, z = 2), x ~ x + 1, is.numeric)
map(data.frame(y = 1:10, z = 2), x ~ x + 1, x ~ all(x == 2))

map(1, x ~ x)
map(list(1:2, 3:4), 2)
map(ML(1:2, 3:4), f(x, y) ~ x + y)
map(ML(1:2, 3:4), f(x, y) ~ x + y, simplify = TRUE)
map(ML(1:2, 3:4), f(x, y, z) ~ x + y + z, z = 1)

map(list(1:3, 2:5), 2:3)
map(list(1:3, 2:5), c(TRUE, FALSE, TRUE))

map(as.numeric(1:2), numeric : x ~ x)
map(1:2, integer(1) : x ~ x)
map(1:2, numeric(1) : x ~ x + 0.5)
}

